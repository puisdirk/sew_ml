
import 'dart:math';

import 'package:petitparser/petitparser.dart';

/// Parses one line of sewMl
class SewMLGrammarDefinition extends GrammarDefinition {

  @override
  Parser<List> start() => (ref0(command).star() & string('.')).pick(0).castList();
  
  Parser command() => ([ref0(point), ref0(line), ref0(curve), failure('Expected a point, line or curve definition')].toChoiceParser() & string('|')).pick(0);
  //((ref0(point) | ref0(line) | ref0(curve)) & string('|')).pick(0);

  Parser point() => (string('point ').trim() & ref0(pointlabel) & ref0(coordinatedefinition)).map((d) {
    return d;
  });

  Parser<String> pointlabel() => (string('origin') | seq2(string('P_'), (letter() | digit()).plus())).flatten().trim().map((d) {
    return d;
  });

  Parser coordinatedefinition() => (ref0(exactcoords) | ref0(coordRelativeToCoord)).map((d) {
    return d;
  });

  // TODO: need to allow formula and no absolute values, so exactcoords will be removed
  Parser exactcoords() => seq4(string('at').trim(), ref0(pFormula), string(',').trim(), ref0(pFormula)).map4((_, x, __, y) {
    return [x,y];
  });

  Parser<double> pDouble() => (digit().star() & (string('.') & digit().star()).optional()).flatten().map((d) {
    return double.parse(d);
  });

  // TODO: inches
  Parser coordRelativeToCoord() => (ref0(mmLength) & ref0(angle) & ref0(coordinateOfPoint)).map((d) {
    return d;
  });

  Parser coordinateOfPoint() => ((string('from') | string('of') | string('to')).trim() & ref0(pointlabel)).map((d) {
    return d;
  });

  Parser mmLength() => (ref0(pFormula) & (string('cm') | string('mm')).trim()).map((d) {
    return d;
  });

  Parser angle() => (ref0(direction) | ref0(angleInDegrees) | ref0(angleInRadians)).map((d) {
    return d;
  });

  Parser direction() => (string('northwest').trim() | string('northeast').trim() | string('southwest').trim() | string('southeast').trim() |
                        string('north').trim() | string('south').trim() | string('east').trim() | string('west').trim() | 
                        string('up').trim() | string('down').trim() | string('right').trim() | string('left').trim()).map((d) {
                          return d;
                        });

  Parser angleInDegrees() => ref0(pFormula) & string('deg').trim();
  Parser angleInRadians() => ref0(pFormula) & string('rad').trim();

  Parser line() => string('line ').trim() & ref0(linelabel) & ref0(coordinateOfPoint) & ref0(coordinateOfPoint);

  Parser<String> linelabel() => seq2(string('L_'), (letter() | digit()).plus()).flatten().trim();

  Parser<double> pFormula() => ref0(expression).map((d) {
    return d;
  }); //(ref0(pMeasurement) | ref0(pDouble)).map((d) {
//    return d;
//  });

  Parser pMeasurement() => ref0(measurementLabel).map((d) {
    return d;
  });

  Parser measurementLabel() => seq2(string('M_'), (letter() | digit()).plus() & string(' ')).flatten().trim().map((d) {
    return d;
  });

  // Maths

  Parser expression() => ref0(term).map((d) {
    return d;
  });

  Parser term() => (ref0(add) | ref0(prod)).map((d) {
    return d;
  });
  
  Parser add() => (ref0(prod) & (char('+') | char('-')).trim() & ref0(term)).map((d) {
    return d[1] == '+' ? d[0] + d[2] : d[0] - d[2];
  });

  Parser prod() => (ref0(mul) | ref0(prim)).map((d) {
    return d;
  });
  
  Parser mul() => (ref0(prim) & (char('*') | char('/')).trim() & ref0(prod)).map((d) {
    return d[1] == '*' ? d[0] * d[2] : d[0] / d[2];
  });

  Parser prim() => (ref0(parens) | ref0(mathsfunction) | ref0(linefunction) | ref0(number)).map((d) {
    return d;
  });
  
  Parser parens() => (char('(').trim() & ref0(term) & char(')').trim()).map((result) {
    return result[1];
  });

  Parser linefunction() => ref0(linelabel) & string('.length');

  Parser mathsfunction() => seq2(
    seq2(letter(), word().star()).flatten('name expected').trim().map((d) {
      return d;
    }),
    seq3(
      char('(').trim(),
      ref0(term).starSeparated(char(',')).map((list) {
        return list.elements;
      }),
      char(')').trim(),
    ).map3((_, list, __) => list).map((d) {
      return d;
    })
  ).map2((name, args) {

    // Here we get a function name and the args list. E.g. cos(5) will give name cos and args [5]
    // Original would create an 'Application' here, but I'll just perform the maths right here and return
    // a double
    
    switch (args.length) {
      case 1:
        switch (name) {
          case 'cos': return cos(args[0]);
          case 'acos': return acos(args[0]);
          case 'sin': return sin(args[0]);
          case 'asin': return asin(args[0]);
          case 'tan': return tan(args[0]);
          case 'atan': return atan(args[0]);
          case 'exp': return exp(args[0]);
          case 'log': return log(args[0]);
          case 'sqrt': return sqrt(args[0]);
          case 'pow': return pow(args[0], 2);
          case 'abs': return (args[0] as double).abs();
          case 'ceil': return (args[0] as double).ceil();
          case 'floor': return (args[0] as double).floor();
          case 'round': return (args[0] as double).round();
          default:
            throw ArgumentError.value(name, 'Unknown function', 'Unknown function $name');
        }
      case 2:
        switch (name) {
          case 'atan2': return atan2(args[0], args[1]);
          case 'max': return max(args[0] as double, args[1] as double);
          case 'min': return min(args[0] as double, args[1] as double);
          case 'pow': return pow(args[0] as double, args[1] as double);

          default:
            throw ArgumentError.value(name, 'Unknown function', 'Unknown function $name');
        }
      default:
        throw ArgumentError.value(name, 'Unknown function', 'Unknown function $name');
    }
  });

  Parser number() => (ref0(pMeasurement) | ref0(pDouble)).map((d) {
    return d;
  });

  //============ Curves ==============

  Parser curve() => ref0(curveThroughTwoPoints);

  // TODO: not yet implemented
  Parser curveThroughFourPoints() => 
    string('curve') & 
    ref0(curvelabel) & 
    // TODO: optional alpha indicator
    string('through') & 
    ref0(pointlabel).starSeparated(char(',')).map((list) {
      return list.elements;
    }).map((d) {
      return d;
    });

  // e.g. curve C_A 1/8 from P_A to P_B
  Parser curveThroughTwoPoints() =>
    string('curve') &
    ref0(curvelabel) &
    (string('pos') | string('neg')).optionalWith('pos').trim() &
//    seq3(digit().plus(), char('/'), digit().plus()).map3((teller, divsign, deler) => (teller as double) / (deler as double)) &
    ref0(pFormula) &
    string('from').trim() &
    ref0(pointlabel) &
    string('to').trim() &
    ref0(pointlabel);


  Parser<String> curvelabel() => seq2(string('C_'), (letter() | digit()).plus()).flatten().trim();

}